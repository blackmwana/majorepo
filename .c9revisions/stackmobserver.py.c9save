{"ts":1360194800284,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#! /usr/bin/env python\n\n# StackMob Web Server v0.1.1\n#\n# This server is used for running HTML5 StackMob applications\n# locally on your computer for development purposes.\n#\n# It functions as a conditional proxy server. Resource\n# files like static html, images, css, etc. are served\n# as a normal http server.  Requests originating from\n# the StackMob JavaScript SDK contain a special HTTP\n# Header that tells this web server to forward requests\n# to the StackMob API Server.\n\nimport cgi, os, SocketServer, sys, time, urllib2, urlparse\nfrom SimpleHTTPServer import SimpleHTTPRequestHandler\nfrom StringIO import StringIO\n\nSTACKMOB_API_SERVER = 'api.stackmob.com'\n\nclass ProxyHandler(SimpleHTTPRequestHandler):\n\n    def handle_request(self):\n        if 'X-StackMob-Proxy-Plain' in self.headers:\n            # PROXY TO STACKMOB\n            self.log_request()\n\n            # Determine Path\n            path = 'http://' + STACKMOB_API_SERVER + self.path\n            print '\\nProxying Request to ' + path\n\n            # Determine Headers\n            headers = {}\n            for key_val in self.headers.items():\n                headers[ key_val[0].upper() ] = key_val[1]\n\n            # Overwrite host header for Proxy\n            netloc = headers['HOST']\n            i = netloc.find(':')\n            if i >= 0:\n                host = netloc[:i], int(netloc[i+1:])\n            else:\n                host = netloc, 80\n\n            headers['HOST'] = STACKMOB_API_SERVER\n            headers['X-FORWARDED-FOR'] = host[0]\n            headers['X-STACKMOB-FORWARDED-PORT'] = host[1]\n            headers['X-STACKMOB-FORWARDED-HOST'] = host[0]\n            headers['X-FORWARDED-PROTO'] = 'HTTP'\n            headers['VERSION'] = 'HTTP/1.1'\n\n            print 'Request Headers'\n            for key in headers:\n                print '\\t%s: %s' % ( key, headers[ key ] )\n\n            # Determine Body Content\n            if 'CONTENT-LENGTH' in self.headers:\n                content_len = int(self.headers.getheader('content-length'))\n                data = self.rfile.read(content_len)\n            else: data = None\n\n            # Create Request\n            opener = urllib2.build_opener(urllib2.HTTPHandler)\n            if data is None:\n                req = urllib2.Request(path, headers=headers)\n            else:\n                req = urllib2.Request(path, data, headers)\n\n            # Connect\n            req.get_method = lambda: self.command\n            try:\n                url = urllib2.urlopen(req)\n                # Send response back to client\n                response_status = 'HTTP/1.1 %s %s\\r\\n' % ( url.getcode(), url.msg )\n                self.connection.send( response_status )\n\n                print 'Response Headers'\n                print '\\t', response_status,\n                for item in url.info().headers:\n                    self.connection.send( item )\n                    print '\\t%s' % ( item ),\n                self.connection.send('\\r\\n')\n                self.connection.send( url.read() )\n                self.connection.close()\n                print\n\n            except urllib2.HTTPError, e:\n                response_status = 'HTTP/1.1 %s %s\\r\\n' % ( e.code, e.msg )\n                self.connection.send( response_status )\n\n                print 'Response Headers'\n                print '\\t', response_status,\n                for item in e.headers:\n                    header = '%s: %s\\r\\n' % ( item, e.headers[ item ] )\n                    self.connection.send( header )\n                    print '\\t' + header,\n                self.connection.send('\\r\\n')\n                self.connection.send( e.fp.read() )\n                self.connection.close()\n                print\n\n            return None\n\n        else:\n            # Default Web Server\n            f = self.send_head()\n            if f:\n                self.copyfile(f, self.wfile)\n                f.close()\n\n    do_GET = handle_request\n    do_POST = handle_request\n    do_HEAD = handle_request\n    do_PUT = handle_request\n    do_DELETE = handle_request\n\nhttpd = SocketServer.TCPServer(('', 4567), ProxyHandler)\nprint 'serving at port', 4567\ntry:\n    print 'Use Control-C to exit'\n    httpd.serve_forever()\nexcept KeyboardInterrupt:\n    print 'Exiting'\n"]],"start1":0,"start2":0,"length1":0,"length2":4223}]],"length":4223}
